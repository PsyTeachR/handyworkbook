# Spearman Correlation

**The Spearman correlation** otherwise known as the Spearman rank correlation coefficient measures the relationship between two variables when that relationship is monotonic. It can be used for relationships that are linear or non-linear. 

As in the Pearson Correlation, the Spearman correlation measures the covariance between two variables, or the shared variance, and then standardises that measure between the values of -1 and 1 with -1 being the perfect negative relationship and 1 being the perfect positive relationship.

The key difference between the Spearman Correlation and the Pearson Correlation is that the Spearman Correlation is based on the rank order of data - i.e. the raw data is converted to ordinal ranks.

If all of the ranks within each variable are unique - i.e. there are no `r glossary("tied ranks", def = "when two or more values/observations within a variable are identical and assume the same rank order value", display = "tied ranks", link = FALSE)` - then the formula for the Spearman Correlation is as follows:

$$\rho = 1 - \frac{6 \times \sum{d_i^2}}{n(n^2-1)}$$
Let's start with a rather simple dataset of 10 participants measured on two scales, A and B. Here is our data:

```{r, echo=FALSE}
dat <- tibble(id = 1:10, a = 11:20, b = 20:11)

dat2 <- dat %>% 
  mutate(a_rank = rank(a,
                       ties.method = "first"),
         b_rank = rank(b,
                       ties.method = "first"),
         d = a_rank - b_rank,
         `d^2` = d^2)

knitr::kable(dat)
```

And to orientate ourselves a little, the table shows Participant 1 scored 11 for scale A and 20 for scale B, and Participant 2 scored 12 for scale A and 19 for scale B.

**Ranking data**

The first step in this analysis is to convert the data in both scales into their respective rank order starting from the smallest value in each scale. For example, the smallest value would get the rank of 1, the second smallest value would get the rank of 2, and so on and so on. If we do that with our data in scale A, we get the following:

```{r, echo=FALSE}
dat2 %>% 
  select(id, a, a_rank, b) %>%
  knitr::kable()
```

And then do the same for the scores in scale b, again starting from the smallest value and giving it a rank of 1, and so on. This would look like:

```{r, echo=FALSE}
dat2 %>% 
  select(id, a, a_rank, b, b_rank) %>%
  knitr::kable()
```

Now we have both scales in their respective rank orders, we can now calculate $d$, each individual participants difference between their ranks on the two scales. For example, with Participant 1, they have a rank of `r dat2 %>% filter(id == 1) %>% pull(a_rank)` on scale A, and a rank of `r dat2 %>% filter(id == 1) %>% pull(b_rank)` on scale B. This would give them a $d$ of `r dat2 %>% filter(id == 1) %>% pull(a_rank)` - `r dat2 %>% filter(id == 1) %>% pull(b_rank)` = `r dat2 %>% filter(id == 1) %>% pull(a_rank) - dat2 %>% filter(id == 1) %>% pull(b_rank)`

If we do that for all the participants we then get:

```{r, echo=FALSE}
dat2 %>% 
  select(id, a, a, a_rank, b, b_rank, d) %>%
  knitr::kable()
```

And finally we want to square each of those individual values to give us a $d^2$ for each participant. For example, Participant 1, with a value of d =`r dat2 %>% filter(id == 1) %>% pull(a_rank) - dat2 %>% filter(id == 1) %>% pull(b_rank)`, would have a $d^2$ of `r dat2 %>% filter(id == 1) %>% pull(a_rank) - dat2 %>% filter(id == 1) %>% pull(b_rank)` $\times$ `r dat2 %>% filter(id == 1) %>% pull(a_rank) - dat2 %>% filter(id == 1) %>% pull(b_rank)` = `r (dat2 %>% filter(id == 1) %>% pull(a_rank) - dat2 %>% filter(id == 1) %>% pull(b_rank))^2` 

And if we do that for all the participants we then get:

```{r, echo=FALSE}
dat2 %>%
  knitr::kable()
```

Now that we have calculated $d^2$ for each participant we can sum them altogether to give us $\sum{d_i^2}$ as follows:

```{r, echo=FALSE}
p1 <- dat2 %>% filter(id == 1) %>% pull(`d^2`)
p2 <- dat2 %>% filter(id == 2) %>% pull(`d^2`)
p3 <- dat2 %>% filter(id == 3) %>% pull(`d^2`)
p4 <- dat2 %>% filter(id == 4) %>% pull(`d^2`)
p5 <- dat2 %>% filter(id == 5) %>% pull(`d^2`)
p6 <- dat2 %>% filter(id == 6) %>% pull(`d^2`)
p7 <- dat2 %>% filter(id == 7) %>% pull(`d^2`)
p8 <- dat2 %>% filter(id == 8) %>% pull(`d^2`)
p9 <- dat2 %>% filter(id == 9) %>% pull(`d^2`)
p10 <- dat2 %>% filter(id == 10) %>% pull(`d^2`)
sumd2 <- dat2 %>% pull(`d^2`) %>% sum()
n <- dim(dat2)[1]
```

$$\sum{d_i^2} = `r p1` + `r p2` + `r p3` + `r p4` + `r p5` + `r p6`+ `r p7` + `r p8` + `r p9` + `r p10`$$

Which gives us:

$$\sum{d_i^2} = `r p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10`$$

**The Correlation**

We can now return to our formula:

$$\rho = 1 - \frac{6 \times \sum{d_i^2}}{n(n^2-1)}$$

And we know that:

* $\sum{d_i^2} = `r sumd2`$
* and $n = `r n`$

Which we can then put into our formula giving:

$$\rho = 1 - \frac{6 \times `r sumd2`}{`r n`(`r n`^2-1)}$$

If we resolve the square in the bottom half of the formula, that gives:

$$\rho = 1 - \frac{6 \times `r sumd2`}{`r n`(`r n^2`-1)}$$

And then subtract the 1, giving:

$$\rho = 1 - \frac{6 \times `r sumd2`}{`r n`(`r n^2-1`)}$$
Now the bottom half can really be read as:

$$\rho = 1 - \frac{6 \times `r sumd2`}{`r n` \times (`r n^2-1`)}$$

Which, when we do the multiplication on the bottom half, gives us:

$$\rho = 1 - \frac{6 \times `r sumd2`}{`r n * (n^2-1)`}$$

And if we then do the multiplication on the top half, we get:

$$\rho = 1 - \frac{`r 6 * sumd2`}{`r n * (n^2-1)`}$$

We then divide the top half by the bottom half to give us:

$$\rho = 1 - `r (6 * sumd2)/(n * (n^2-1))`$$

And we do the final subtraction, leaving us:

$$\rho = `r 1 - ((6 * sumd2)/(n * (n^2-1)))`$$
Meaning that we have a spearman rho of $\rho = `r 1 - ((6 * sumd2)/(n * (n^2-1)))`$

## Section glossary

```{r gloss-tab, echo=FALSE, results='asis'}

glossary_table()
```

